<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>TatvaBot â€” Chat + Image Upload (Voice + Location + Diagnosis)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{
    --green:#14532d;
    --muted:#f7f7f8;
    --bubble-bg:#f1f5f9;
    --text:#111827;
    --accent:#16a34a;
    --muted-border:#e6e6e6;
    --muted-dark:#e6e6e6;
    --danger:#c53030;
  }
  html,body{
    height:100%;
    margin:0;
    font-family:system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial;
    background:var(--muted);
  }
  body{
    display:flex;
    align-items:center;
    justify-content:center;
    padding:18px;
  }

  /* container */
  .chat-wrapper{
    width:100%; max-width:960px;
    background:#fff; border-radius:12px;
    box-shadow:0 12px 30px rgba(2,6,23,0.08);
    overflow:hidden;
    display:flex; flex-direction:column;
    min-height:560px;
    height:80vh; /* fixed viewport so chat-window can scroll */
  }

  /* header - fixed inside wrapper */
  .chat-header{
    background:var(--green);
    color:#fff;
    padding:10px 14px;
    font-weight:600;
    display:flex;
    justify-content:space-between;
    align-items:center;
    position:sticky;
    top:0;
    z-index:1000;
  }
  .chat-header-left{display:flex; gap:12px; align-items:center;}
  .chat-header small{
    display:block;
    font-weight:400;
    font-size:12px;
    opacity:.95;
    margin-top:2px;
  }
  .header-controls{ display:flex; gap:8px; align-items:center; }

  .btn-clear{
    background:transparent; border:1px solid rgba(255,255,255,0.18); color:#fff; padding:6px 8px; border-radius:8px; cursor:pointer; font-size:13px;
  }
  .btn-ghost{
    background:transparent; color:#fff; border:1px solid rgba(255,255,255,0.12); padding:6px 8px;border-radius:8px;cursor:pointer;font-size:13px;
  }

  /* body area holds the scrollable chat-window */
  .chat-body{
    display:flex;
    gap:0;
    padding:18px;
    flex:1 1 auto;
    min-height:0;  /* important so child can scroll */
    box-sizing:border-box;
  }

  .chat-window{
    flex:1;
    background:#fafafa;
    border-radius:8px;
    padding:14px;
    overflow:auto;
    height:100%;
    box-sizing:border-box;
  }

  .msg{
    margin-bottom:12px;
    max-width:78%;
    line-height:1.4;
    display:flex;
    flex-direction:column;
  }
  .msg span{
    display:block;
    background:var(--bubble-bg);
    color:var(--text);
    padding:12px 14px;
    border-radius:12px;
    white-space:pre-wrap;
    word-wrap:break-word;
    box-shadow:0 1px 0 rgba(0,0,0,0.02);
  }
  .msg .meta {
    font-size:11px; color:#7b7b7b; margin-top:6px;
  }
  .msg-user{
    align-items:flex-end;
    margin-left:auto;
    text-align:right;
  }
  .msg-user span{
    background:var(--green);
    color:#fff;
  }
  .msg img{
    display:block;
    margin-top:8px;
    max-width:320px;
    border-radius:8px;
    box-shadow:0 6px 18px rgba(2,6,23,0.06);
  }

  /* typing indicator */
  .typing {
    display:inline-block;
    padding:8px 12px;
    background:#ececec;
    border-radius:12px;
  }
  .typing .dot { width:6px;height:6px;background:#9a9a9a;border-radius:50%;display:inline-block;margin:0 3px;opacity:.6; animation: blink 1s infinite; }
  .typing .dot:nth-child(2){ animation-delay:.15s; } .typing .dot:nth-child(3){ animation-delay:.3s; }
  @keyframes blink { 0%{opacity:.15} 50%{opacity:1} 100%{opacity:.15} }

  /* footer (controls) pinned to bottom of wrapper */
  .chat-footer{
    border-top:1px solid var(--muted-border);
    padding:12px 14px;
    display:flex;
    gap:8px;
    align-items:center;
    background:#fff;
  }

  .chat-footer input[type="text"]{
    flex:1;
    padding:10px 14px;
    border-radius:999px;
    border:1px solid #ddd;
    outline:none;
    font-size:14px;
  }
  .chat-footer input[type="text"]:focus{ border-color:var(--green); }

  .file-btn{
    padding:8px 10px;
    border-radius:8px;
    border:1px solid #ddd;
    background:#fff;
    cursor:pointer;
    font-size:16px;
    line-height:1;
  }

  .send{
    background:var(--accent);
    color:#fff;
    border:none;
    padding:10px 16px;
    border-radius:999px;
    cursor:pointer;
  }
  .send:disabled{ opacity:.6; cursor:default; }

  .mic-btn{
    width:40px; height:40px; border-radius:999px; border:1px solid #ddd; display:flex; align-items:center; justify-content:center; cursor:pointer; background:#fff;
  }
  .mic-btn.recording{ box-shadow:0 0 0 6px rgba(197,48,48,0.08); border-color:var(--danger); }

  .status{
    font-size:13px;
    color:#6b7280;
    padding:6px 18px 10px;
    min-height:20px;
  }

  /* quick buttons area (optional, inline) */
  .quick-row{ display:flex; gap:10px; flex-wrap:wrap; margin:8px 0; }
  .quick-btn{ background:#fff; border:1px solid var(--muted-dark); padding:8px 12px; border-radius:999px; cursor:pointer; font-size:13px; }
  .quick-btn.primary{ background:var(--green); color:#fff; border-color:var(--green); }

  @media(max-width:640px){
    .msg img{ max-width:220px; }
  }
</style>
</head>
<body>
  <div class="chat-wrapper" role="application" aria-label="TatvaBot chat">
    <div class="chat-header" id="chat-header">
      <div class="chat-header-left">
        <div>
          <div style="font-size:16px"><strong>TatvaBot â€” Gardening Assistant</strong></div>
          <small>Ask about vermicompost, terrace gardening, or Tatvabhoomi products</small>
        </div>
      </div>

      <div class="header-controls">
        <div id="location-display" style="font-size:13px; opacity:.95">Location â€” <em>not set</em></div>
        <button id="share-location" class="btn-ghost" title="Share device location">Share location</button>
        <button id="set-location" class="btn-ghost" title="Set location manually">Set location</button>
        <div style="font-size:12px;opacity:.95">v1</div>
        <button id="clear-btn" class="btn-clear" title="Clear chat history">Clear chat</button>
      </div>
    </div>

    <div class="chat-body">
      <div id="chat-window" class="chat-window" aria-live="polite" role="log">
        <!-- restored messages appear here -->
      </div>
    </div>

    <div id="status" class="status" aria-live="polite"></div>

    <div class="chat-footer" role="region" aria-label="Chat controls">
      <input id="user-input" type="text" placeholder="Type your question or use the mic..." autocomplete="off" aria-label="Type message" />
      <!-- voice mic -->
      <div id="mic-btn" class="mic-btn" title="Start voice input" aria-pressed="false">ðŸŽ¤</div>

      <!-- attach icon opens file chooser. File selection auto-uploads. -->
      <label class="file-btn" id="choose-file-btn" title="Attach image (camera or gallery)">ðŸ“Ž</label>
      <input id="file-input" type="file" accept="image/*" capture="environment" style="display:none" />

      <button id="send-btn" class="send" aria-label="Send message">Send</button>
    </div>
  </div>

<script>
/*
  Single-file UI with:
    - multistep smart diagnosis flows
    - automatic sending of diagnosis summaries to Formspree
    - voice, location, upload, persistence, quick buttons preserved
*/

/* ===== CONFIG ===== */
const FORMSPREE_ENDPOINT = "https://formspree.io/f/xwpdkjaa"; // your endpoint
const STORAGE_KEY_BASE = 'tatvabot_chat';
const STORAGE_VERSION = 'v3';
const STORAGE_KEY = STORAGE_KEY_BASE + '_' + STORAGE_VERSION;
const LOCATION_KEY = 'tatvabot_location_' + STORAGE_VERSION;

/* ===== DIAGNOSIS FLOWS (edit or add flows here) =====
 Each flow: id, title, steps: array of { key, q, type }.
 type can be 'text' or 'yn' or 'choice' (choice expects options array).
*/
const DIAG_FLOWS = {
  leaf_holes: {
    id: 'leaf_holes',
    title: 'Leaf holes / pests diagnosis',
    steps: [
      { key: 'plant_type', q: 'What type of plant is affected (e.g., rose, money plant)?', type: 'text' },
      { key: 'visible_pests', q: 'Do you see any insects, caterpillars, or snails on the leaves?', type: 'yn' },
      { key: 'damage_when', q: 'Are the holes on new leaves, old leaves, or throughout?', type:'choice', options:['new leaves','old leaves','throughout'] },
      { key: 'watering_freq', q: 'How often do you water this plant?', type:'text' },
      { key: 'lighting', q: 'Where is the plant kept? (sun/shade/partial)', type:'choice', options:['sun','shade','partial'] }
    ]
  },
  yellow_leaves: {
    id: 'yellow_leaves',
    title: 'Yellow leaves diagnosis',
    steps: [
      { key: 'plant_type', q: 'Which plant has yellow leaves?', type:'text' },
      { key: 'pattern', q: 'Is the yellowing from edge inwards, uniform, or just lower leaves?', type:'choice', options:['edge to center','uniform','lower leaves only'] },
      { key: 'watering', q: 'Watering frequency?', type:'text' },
      { key: 'fertilized', q: 'Have you recently applied fertilizer? (yes/no)', type:'yn' }
    ]
  },
  powdery_mildew: {
    id: 'powdery_mildew',
    title: 'Powdery mildew check',
    steps: [
      { key: 'plant_type', q: 'Which plant shows white powdery patches?', type:'text' },
      { key: 'appearance', q: 'Are the patches powdery (can be brushed off) or more like spots?', type:'choice', options:['powdery','spots'] },
      { key: 'humidity', q: 'Is the plant in a humid / poorly ventilated area? (yes/no)', type:'yn' }
    ]
  },
  soil_smell: {
    id: 'soil_smell',
    title: 'Soil smell / drainage check',
    steps: [
      { key: 'plant_type', q: 'Which plant has a soil smell / drainage issue?', type:'text' },
      { key: 'symptom', q: 'Do you see water pooling or slow drainage after watering? (yes/no)', type:'yn' },
      { key: 'soil_type', q: 'Describe the potting mix (heavy, sandy, loamy):', type:'text' }
    ]
  }
};
/* ===== END FLOWS ===== */

/* ===== DOM references ===== */
const chatWindow    = document.getElementById('chat-window');
const input         = document.getElementById('user-input');
const sendBtn       = document.getElementById('send-btn');
const fileInput     = document.getElementById('file-input');
const chooseFileBtn = document.getElementById('choose-file-btn');
const statusEl      = document.getElementById('status');
const clearBtn      = document.getElementById('clear-btn');
const micBtn        = document.getElementById('mic-btn');
const shareLocBtn   = document.getElementById('share-location');
const setLocBtn     = document.getElementById('set-location');
const locationDisplay = document.getElementById('location-display');

let uploadedImageUrl     = null;
let lastUploadedUrlShown = null;
let recognition = null;
let isRecording = false;
let diagnosisState = null; // { flowId, flow, idx, answers }

/* phone regex */
const PHONE_REGEX = /(\+?\d[\d\-\s]{8,15}\d)/;

/* ---------- persistence helpers ---------- */
function saveHistory(messages){
  try { localStorage.setItem(STORAGE_KEY, JSON.stringify(messages)); } catch(e){ console.warn(e); }
}
function loadHistory(){
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return null;
    return JSON.parse(raw);
  } catch(e){ console.warn(e); return null; }
}
function clearHistory(){
  try {
    localStorage.removeItem(STORAGE_KEY);
    chatWindow.innerHTML = '';
    ensureInitialMessage();
  } catch(e){ console.warn(e); }
}

/* location */
function saveLocation(loc){ try { localStorage.setItem(LOCATION_KEY, JSON.stringify(loc)); } catch(e){ console.warn(e); } }
function loadLocation(){ try { const raw = localStorage.getItem(LOCATION_KEY); if(!raw) return null; return JSON.parse(raw);} catch(e){ return null; } }
function setLocationDisplay(loc){
  if(!loc) locationDisplay.innerHTML = 'Location â€” <em>not set</em>';
  else if(loc.name) locationDisplay.innerHTML = 'Location â€” ' + escapeHtml(loc.name);
  else if(loc.coords) {
    const c = loc.coords;
    locationDisplay.innerHTML = 'Location â€” ' + c.latitude.toFixed(3) + ',' + c.longitude.toFixed(3);
  } else locationDisplay.innerHTML = 'Location â€” <em>not set</em>';
}

/* ---------- rendering ---------- */
function formatTime(ts){
  const d = new Date(ts || Date.now());
  return d.toLocaleTimeString([], { hour: '2-digit', minute:'2-digit' });
}

function createMessageElement({ text, from='bot', imageUrl=null, ts }){
  const wrapper = document.createElement('div');
  wrapper.className = 'msg ' + (from==='user' ? 'msg-user' : 'msg-bot');
  const span = document.createElement('span');
  span.innerHTML = (text || '') .replace(/\n/g,'<br>');
  wrapper.appendChild(span);
  if(imageUrl){
    const img = document.createElement('img');
    img.src = imageUrl;
    img.alt = 'image';
    img.loading = 'lazy';
    wrapper.appendChild(img);
  }
  const meta = document.createElement('div');
  meta.className = 'meta';
  meta.textContent = formatTime(ts);
  wrapper.appendChild(meta);
  return wrapper;
}

function addMessage(text, from='bot', imageUrl=null, ts=Date.now(), save=true){
  const el = createMessageElement({ text, from, imageUrl, ts });
  chatWindow.appendChild(el);
  chatWindow.scrollTop = chatWindow.scrollHeight;
  if(save){
    const hist = loadHistory() || [];
    hist.push({ text, from, imageUrl, ts });
    saveHistory(hist);
  }
}

/* typing indicator */
function showTypingIndicator(){
  const el = document.createElement('div');
  el.className = 'msg msg-bot typing-wrap';
  const span = document.createElement('span');
  span.className = 'typing';
  span.innerHTML = '<span class="dot"></span><span class="dot"></span><span class="dot"></span>';
  el.appendChild(span);
  chatWindow.appendChild(el);
  chatWindow.scrollTop = chatWindow.scrollHeight;
  return el;
}
function removeTypingIndicator(el){ if(el && el.parentNode) el.parentNode.removeChild(el); }
function escapeHtml(s){ return String(s).replace(/[&<>"']/g, function(m){ return ({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' })[m]; }); }

/* ---------- restore or initial ---------- */
function ensureInitialMessage(){
  const initial = "ðŸ‘‹ Namaste! Iâ€™m TatvaBot. How can I help with your plants today?";
  addMessage(initial, 'bot', null, Date.now(), true);
  injectQuickRow();
}
(function restore(){
  const hist = loadHistory();
  const loc = loadLocation();
  setLocationDisplay(loc);
  if(!hist || !hist.length){
    chatWindow.innerHTML = '';
    ensureInitialMessage();
    return;
  }
  chatWindow.innerHTML = '';
  hist.forEach(msg => {
    const el = createMessageElement(msg);
    chatWindow.appendChild(el);
  });
  injectQuickRow();
  chatWindow.scrollTop = chatWindow.scrollHeight;
})();

/* ---------- quick buttons ---------- */
function injectQuickRow(){
  if(document.getElementById('quick-row')) return;
  const row = document.createElement('div');
  row.id = 'quick-row';
  row.className = 'quick-row';
  row.style.marginBottom = '14px';
  const items = [
    {t:'Why are leaves yellow?', cls:''},
    {t:'Powdery mildew', cls:''},
    {t:'Leaf holes / pests', cls:''},
    {t:'Soil smell / drainage', cls:''},
    {t:'Buy vermicompost', cls:'primary'},
    {t:'Start detailed diagnosis', cls:''}
  ];
  items.forEach(it => {
    const b = document.createElement('button');
    b.className = 'quick-btn ' + (it.cls || '');
    b.setAttribute('data-q', it.t);
    b.textContent = it.t;
    row.appendChild(b);
  });
  let firstChild = chatWindow.firstChild;
  if(firstChild) chatWindow.insertBefore(row, firstChild.nextSibling);
  else chatWindow.appendChild(row);

  row.addEventListener('click', (ev) => {
    const btn = ev.target.closest('button[data-q]');
    if(!btn) return;
    const q = btn.getAttribute('data-q');
    if(q === 'Start detailed diagnosis'){
      // present a choice of flows
      presentFlowChoices();
      return;
    }
    // map quick button labels to actions/flows
    if(q === 'Leaf holes / pests' || q.toLowerCase().includes('leaf holes')){
      startDiagnosis('leaf_holes');
      return;
    }
    if(q.toLowerCase().includes('yellow')){
      startDiagnosis('yellow_leaves');
      return;
    }
    if(q.toLowerCase().includes('powdery')){
      startDiagnosis('powdery_mildew');
      return;
    }
    if(q.toLowerCase().includes('soil')){
      startDiagnosis('soil_smell');
      return;
    }
    // fallback: type into input
    input.value = q;
    sendMessage();
  });
}

/* ---------- UI helpers ---------- */
function showStatus(text){ statusEl.textContent = text || ''; }

/* ---------- upload flow (unchanged) ---------- */
chooseFileBtn.addEventListener('click', () => fileInput.click());

fileInput.addEventListener('change', async () => {
  const file = fileInput.files && fileInput.files[0];
  if(!file) return;
  showStatus('Uploading image...');
  chooseFileBtn.disabled = true;
  sendBtn.disabled = true;
  try {
    const fd = new FormData();
    fd.append('file', file);
    const res  = await fetch('/api/upload', { method: 'POST', body: fd });
    const data = await res.json().catch(()=>null);
    if(res.ok && data && (data.url || data.secure_url || (data.result && data.result.secure_url) || (data.result && data.result.url))){
      uploadedImageUrl = data.url || data.secure_url || (data.result && data.result.secure_url) || (data.result && data.result.url) || null;
      if(uploadedImageUrl && uploadedImageUrl !== lastUploadedUrlShown){
        addMessage('Image attached', 'user', uploadedImageUrl);
        lastUploadedUrlShown = uploadedImageUrl;
      }
      showStatus('Upload OK');
    } else {
      console.error('Upload failed', res, data);
      alert('Upload failed. Check server logs and console.');
      showStatus('Upload failed');
    }
  } catch(err){
    console.error('Upload error', err);
    alert('Upload error: ' + (err.message || err));
    showStatus('Upload error');
  } finally {
    fileInput.value = '';
    chooseFileBtn.disabled = false;
    sendBtn.disabled = false;
    setTimeout(()=>showStatus(''), 1600);
  }
});

/* ---------- SEND FLOW (Formspree phone detection preserved) ---------- */
async function sendMessage(){
  const messageRaw  = input.value.trim();
  const imageToSend = uploadedImageUrl || null;
  if(!messageRaw && !imageToSend) return;
  const phoneMatch = messageRaw.match(PHONE_REGEX);

  if (phoneMatch) {
    const phoneRaw    = phoneMatch[1];
    const phoneDigits = phoneRaw.replace(/\D/g, '');
    if(imageToSend && lastUploadedUrlShown === imageToSend){
      addMessage(messageRaw || 'Image', 'user', null);
    } else {
      addMessage(messageRaw || 'Image', 'user', imageToSend);
      lastUploadedUrlShown = imageToSend;
    }
    input.value = '';
    showStatus('Saving your number...');
    sendBtn.disabled = true;
    try {
      await fetch(FORMSPREE_ENDPOINT, {
        method: 'POST',
        headers: { 'Accept': 'application/json', 'Content-Type': 'application/json' },
        body: JSON.stringify({
          phone: phoneDigits,
          message: messageRaw,
          source: 'TatvaBot chat',
          location: loadLocation()
        })
      });
      addMessage("Thank you! ðŸŒ± Your number has been shared with the Tatvabhoomi team. Weâ€™ll reach out to you soon. Meanwhile, you can keep asking your plant questions here.", 'bot');
    } catch(err){
      console.error('Formspree error', err);
      addMessage("I tried to save your number but something went wrong. Please try again later.", 'bot');
    } finally {
      uploadedImageUrl = null;
      sendBtn.disabled = false;
      showStatus('');
    }
    return;
  }

  // If we're in a diagnosis flow and the bot is asking a question, treat message as an answer
  if(diagnosisState && diagnosisState.awaiting) {
    // record the answer and proceed
    recordDiagnosisAnswer(messageRaw);
    return;
  }

  // Normal chat flow
  const message = messageRaw;
  if(imageToSend && lastUploadedUrlShown === imageToSend){
    addMessage(message || 'Image', 'user', null);
  } else {
    addMessage(message || 'Image', 'user', imageToSend);
    lastUploadedUrlShown = imageToSend;
  }
  input.value = '';
  showStatus('TatvaBot is thinking...');
  sendBtn.disabled = true;
  const typingEl = showTypingIndicator();
  try {
    const body = { message: message || '', image: imageToSend || null, location: loadLocation() || null };
    const res  = await fetch('/api/chat', {
      method: 'POST',
      headers: { 'Content-Type':'application/json' },
      body: JSON.stringify(body)
    });
    const data = await res.json().catch(()=>null);
    await new Promise(r => setTimeout(r, 650));
    if(res.ok && data && (data.reply || data.answer || data.text)){
      const replyText  = data.reply || data.answer || data.text || '';
      const replyImage = data.image || data.img || (data.result && data.result.secure_url) || null;
      removeTypingIndicator(typingEl);
      addMessage(replyText, 'bot', replyImage || null);
    } else {
      console.error('Chat API error', res, data);
      removeTypingIndicator(typingEl);
      addMessage('Sorry â€” tatvabot had trouble replying. Try again later.', 'bot');
    }
  } catch(err){
    console.error('Network error', err);
    removeTypingIndicator(typingEl);
    addMessage('Network error. Please check your connection and try again.', 'bot');
  } finally {
    uploadedImageUrl = null;
    sendBtn.disabled = false;
    showStatus('');
  }
}

/* ---------- DIAGNOSIS ENGINE ---------- */
function presentFlowChoices(){
  // show simple list of flows as bot message and let user click
  let text = "Which problem should I help diagnose? Choose one:";
  let html = text + "<br>";
  Object.values(DIAG_FLOWS).forEach(f => {
    html += <div><button class="quick-btn diag-choice" data-flow="${escapeHtml(f.id)}">${escapeHtml(f.title)}</button></div>;
  });
  addMessage(html, 'bot', null);
  // attach handler to newly added buttons (they will be in DOM)
  setTimeout(() => {
    const container = chatWindow.querySelectorAll('.diag-choice');
    container.forEach(btn => {
      btn.addEventListener('click', (ev) => {
        const flowId = ev.currentTarget.getAttribute('data-flow');
        startDiagnosis(flowId);
      });
    });
  }, 50);
}

function startDiagnosis(flowId){
  const flow = DIAG_FLOWS[flowId];
  if(!flow){
    addMessage("Sorry â€” couldn't find that diagnosis flow.", 'bot');
    return;
  }
  // initialize diagnosis state
  diagnosisState = { flowId: flow.id, flow: flow, idx: 0, answers: {}, awaiting: false };
  // announce and ask first question
  addMessage(Starting diagnosis: *${flow.title}* â€” I will ask a few quick questions. You can type or use the quick replies., 'bot');
  askDiagnosisQuestion();
}

function askDiagnosisQuestion(){
  if(!diagnosisState) return;
  const step = diagnosisState.flow.steps[diagnosisState.idx];
  if(!step){
    finishDiagnosis();
    return;
  }
  // Compose quick prompt depending on type
  let prompt = step.q;
  if(step.type === 'yn') prompt += ' (yes / no)';
  else if(step.type === 'choice' && step.options) prompt += ' â€” options: ' + step.options.join(' / ');
  addMessage(prompt, 'bot');
  diagnosisState.awaiting = true;
  // show as awaiting â€” input will be recorded by sendMessage if user types
}

function recordDiagnosisAnswer(text){
  if(!diagnosisState) return;
  const step = diagnosisState.flow.steps[diagnosisState.idx];
  if(!step) return;
  // basic normalization for yn
  let value = text.trim();
  if(step.type === 'yn'){
    const lc = value.toLowerCase();
    if(lc.startsWith('y')) value = 'yes';
    else if(lc.startsWith('n')) value = 'no';
  }
  // store
  diagnosisState.answers[step.key] = value;
  // show user's answer as a message (but avoid duplicate thumbnail behavior)
  addMessage(value, 'user', null);
  diagnosisState.idx++;
  diagnosisState.awaiting = false;
  // next question after small pause
  setTimeout(askDiagnosisQuestion, 350);
}

function finishDiagnosis(){
  if(!diagnosisState) return;
  const flow = diagnosisState.flow;
  const answers = diagnosisState.answers;
  // build readable summary
  let summary = Diagnosis: ${flow.title}\n\n;
  Object.keys(answers).forEach(k => {
    summary += ${k.replace(/_/g,' ')}: ${answers[k]}\n;
  });
  // include optional location if set
  const loc = loadLocation();
  if(loc) summary += \nLocation: ${ loc.name ? loc.name : (loc.coords ? (loc.coords.latitude.toFixed(4)+','+loc.coords.longitude.toFixed(4)) : 'set') }\n;
  // show summary
  addMessage("Here's a short summary of the answers I collected:", 'bot');
  addMessage(summary, 'bot');
  // send to Formspree automatically
  sendDiagnosisToFormspree(flow.title, summary, answers);
  // clear diagnosis state
  diagnosisState = null;
}

async function sendDiagnosisToFormspree(title, summary, answers){
  showStatus('Sending diagnosis summary to Tatvabhoomi...');
  try{
    // try to find phone in answers
    let phone = null;
    Object.values(answers).forEach(v => {
      if(!phone){
        const m = String(v).match(PHONE_REGEX);
        if(m) phone = m[1].replace(/\D/g,'');
      }
    });
    const payload = {
      subject: Diagnosis: ${title},
      summary: summary,
      source: 'TatvaBot multistep diagnosis',
      phone: phone || null,
      location: loadLocation() || null
    };
    await fetch(FORMSPREE_ENDPOINT, {
      method: 'POST',
      headers: { 'Accept': 'application/json', 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });
    addMessage("âœ… I have sent the diagnosis summary to the Tatvabhoomi team. They'll review and follow up if needed.", 'bot');
  } catch(err){
    console.error('Formspree send error', err);
    addMessage("âš ï¸ I couldn't send the summary automatically â€” maybe network issues. Please try again later.", 'bot');
  } finally {
    showStatus('');
  }
}

/* ---------- handlers ---------- */
sendBtn.addEventListener('click', sendMessage);
input.addEventListener('keydown', (e) => {
  if(e.key === 'Enter'){
    e.preventDefault();
    sendMessage();
  }
});
clearBtn.addEventListener('click', () => {
  if(confirm('Clear saved chat history? This cannot be undone.')){
    clearHistory();
  }
});

/* ---------- VOICE (same as before) ---------- */
function initSpeech(){
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  if(!SpeechRecognition){
    micBtn.title = 'Voice input not supported in this browser';
    micBtn.style.opacity = 0.6;
    return null;
  }
  const rec = new SpeechRecognition();
  rec.lang = 'en-IN';
  rec.interimResults = true;
  rec.maxAlternatives = 1;
  return rec;
}
function startRecording(){
  if(!recognition) recognition = initSpeech();
  if(!recognition) {
    alert('Voice input not supported by this browser.');
    return;
  }
  isRecording = true;
  micBtn.classList.add('recording');
  micBtn.setAttribute('aria-pressed','true');
  showStatus('Listening... Tap mic to stop');
  let interim = '';
  let finalText = '';
  recognition.onresult = (event) => {
    interim = '';
    for(let i=event.resultIndex; i < event.results.length; i++){
      const r = event.results[i];
      if(r.isFinal) finalText += r[0].transcript;
      else interim += r[0].transcript;
    }
    input.value = (finalText + interim).trim();
  };
  recognition.onerror = (ev) => {
    console.error('Speech error', ev);
    stopRecording();
    showStatus('Voice recognition error');
    setTimeout(()=>showStatus(''), 1500);
  };
  recognition.onend = () => {
    isRecording = false;
    micBtn.classList.remove('recording');
    micBtn.setAttribute('aria-pressed','false');
    showStatus('');
    if(input.value.trim()) sendMessage();
  };
  recognition.start();
}
function stopRecording(){
  if(!recognition) return;
  try { recognition.stop(); } catch(e){ }
  isRecording = false;
  micBtn.classList.remove('recording');
  micBtn.setAttribute('aria-pressed','false');
  showStatus('');
}
micBtn.addEventListener('click', () => {
  if(isRecording) stopRecording(); else startRecording();
});

/* ---------- LOCATION ---------- */
shareLocBtn.addEventListener('click', () => {
  if(!navigator.geolocation){
    alert('Geolocation not supported in this browser.');
    return;
  }
  showStatus('Requesting location...');
  navigator.geolocation.getCurrentPosition((pos) => {
    const loc = { coords: { latitude: pos.coords.latitude, longitude: pos.coords.longitude }, timestamp: Date.now() };
    saveLocation(loc);
    setLocationDisplay(loc);
    showStatus('Location saved');
    setTimeout(()=>showStatus(''), 1500);
  }, (err) => {
    console.error('geo error', err);
    showStatus('Could not get location');
    setTimeout(()=>showStatus(''), 1500);
  }, { enableHighAccuracy: false, timeout: 10000 });
});
setLocBtn.addEventListener('click', () => {
  const name = prompt('Enter your city or locality (e.g. "Bengaluru, India")');
  if(name && name.trim()){
    const loc = { name: name.trim(), timestamp: Date.now() };
    saveLocation(loc);
    setLocationDisplay(loc);
    showStatus('Location saved');
    setTimeout(()=>showStatus(''), 1500);
  }
});
setLocationDisplay(loadLocation());

/* ---------- finish init ---------- */
input.focus();
console.info('TatvaBot UI loaded â€” storage key: %s, location key: %s', STORAGE_KEY, LOCATION_KEY);

</script>
</body>
</html>
